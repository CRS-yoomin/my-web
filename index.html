<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>YOLO 객체 라벨링 툴</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    body {
      background-color: #f8f9fa;
    }

    canvas {
      border: 1px solid #000;
      display: block;
      margin: 20px auto;
      cursor: crosshair;
    }

    .upload-box {
      border: 2px dashed #aaa;
      padding: 30px;
      text-align: center;
      cursor: pointer;
      color: #555;
      margin: 30px auto;
      max-width: 800px;
      background-color: white;
    }

    .label-selector {
      margin: 20px auto;
      text-align: center;
    }

    #labelList {
      text-align: center;
      font-size: 0.9em;
    }
  </style>
</head>

<body>
  <div class="container">
    <h1 class="text-center mt-4">YOLO 라벨링 툴</h1>

    <div class="label-selector">
      <label for="selectedLabel">라벨 선택:</label>
      <select id="selectedLabel">
        <option value="jellyfish">jellyfish</option>
        <option value="plastic">plastic</option>
        <option value="net">net</option>
      </select>
    </div>

    <div class="upload-box" onclick="document.getElementById('fileInput').click();">
      여기를 클릭해 이미지 업로드
      <input type="file" id="fileInput" accept="image/*" style="display:none">
    </div>

    <canvas id="canvas"></canvas>
    <div id="labelList"></div>

    <div class="text-center">
      <button class="btn btn-primary mt-3" onclick="downloadLabels()">YOLO 형식으로 저장</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const fileInput = document.getElementById('fileInput');
    const labelColors = {
      jellyfish: 'red',
      plastic: 'blue',
      net: 'green'
    };
    let boxes = [], image = new Image();
    let startX, startY, currentX, currentY, isDrawing = false;

    fileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function (event) {
        image.src = event.target.result;
      };
      reader.readAsDataURL(file);
    });

    image.onload = () => {
      canvas.width = image.naturalWidth;
      canvas.height = image.naturalHeight;
      boxes = [];
      drawAll();
    };

    canvas.addEventListener('mousedown', (e) => {
      const pos = getMousePos(e);
      startX = pos.x;
      startY = pos.y;
      isDrawing = true;
    });

    canvas.addEventListener('mousemove', (e) => {
      if (!isDrawing) return;
      const pos = getMousePos(e);
      currentX = pos.x;
      currentY = pos.y;
      drawAll(true);
    });

    canvas.addEventListener('mouseup', (e) => {
      isDrawing = false;
      const pos = getMousePos(e);
      const label = document.getElementById('selectedLabel').value;
      const x = Math.min(startX, pos.x);
      const y = Math.min(startY, pos.y);
      const w = Math.abs(pos.x - startX);
      const h = Math.abs(pos.y - startY);
      if (w < 10 || h < 10) return;
      boxes.push({ x, y, width: w, height: h, label });
      drawAll();
      updateLabelList();
    });

    canvas.addEventListener('contextmenu', (e) => {
      e.preventDefault();
      const pos = getMousePos(e);
      const i = boxes.findIndex(b => pos.x >= b.x && pos.x <= b.x + b.width && pos.y >= b.y && pos.y <= b.y + b.height);
      if (i !== -1) {
        boxes.splice(i, 1);
        drawAll();
        updateLabelList();
      }
    });

    function getMousePos(e) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: (e.clientX - rect.left) * (canvas.width / rect.width),
        y: (e.clientY - rect.top) * (canvas.height / rect.height)
      };
    }

    function drawAll(temp = false) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(image, 0, 0);
      boxes.forEach(b => {
        ctx.strokeStyle = labelColors[b.label] || 'black';
        ctx.lineWidth = 2;
        ctx.strokeRect(b.x, b.y, b.width, b.height);
      });
      if (temp && isDrawing) {
        ctx.strokeStyle = 'gray';
        ctx.setLineDash([4, 4]);
        ctx.strokeRect(Math.min(startX, currentX), Math.min(startY, currentY), Math.abs(currentX - startX), Math.abs(currentY - startY));
        ctx.setLineDash([]);
      }
    }

    function updateLabelList() {
      document.getElementById('labelList').innerHTML = '<b>라벨 목록:</b><br>' +
        boxes.map((b, i) => `${i + 1}) ${b.label} [x:${b.x.toFixed(1)}, y:${b.y.toFixed(1)}, w:${b.width.toFixed(1)}, h:${b.height.toFixed(1)}]`).join('<br>');
    }

    function downloadLabels() {
      if (boxes.length === 0) return alert('라벨이 없습니다.');
      const labelMap = {};
      let classId = 0;
      const lines = boxes.map(b => {
        if (!(b.label in labelMap)) labelMap[b.label] = classId++;
        const cx = (b.x + b.width / 2) / canvas.width;
        const cy = (b.y + b.height / 2) / canvas.height;
        const w = b.width / canvas.width;
        const h = b.height / canvas.height;
        return `${labelMap[b.label]} ${cx.toFixed(6)} ${cy.toFixed(6)} ${w.toFixed(6)} ${h.toFixed(6)}`;
      });
      const blob = new Blob([lines.join('\n')], { type: 'text/plain' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'labels.txt';
      a.click();
    }
  </script>
</body>

</html>
